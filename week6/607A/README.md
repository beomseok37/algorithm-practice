바이너리 서치 문제였다......

이 문제의 핵심은 비콘이 활성화되면 무조건 비활성화되는 비콘이 있다는 것을 알고 그것을 알고리즘에 대입해서 푸는 것이라고 생각한다.

그것을 생각하지 못하고 문제를 풀어, 각 비콘이 다른 비콘에 영향을 받을지 안 받을지를 알고리즘에 적용을 하느라 시간이 오래걸렸다.

**한 조건으로 인해 다른 조건은 아예 실행되지 않을 경우를 생각을 해봐야겠다.**

### 푼 방식

각 비콘 당 자신이 살아남았을 경우 자신이 비활성화 시키는 비콘들의 개수를 담을 dp배열을 만든다.

각 원소는 power에 의해 비활성화 시킬 비콘을 알고 있고, 비활성화 시킨 비콘 바로 옆의 비콘은 활성화 되어 또 자신의 왼쪽의 비콘들을 비활성화 시킬 것이다. 이것을 이용해 각 i번째 비콘이 temp+1까지의 비콘을 비활성화 시킨다면 `dp[i] = dp[temp]+i-temp-1`가 된다.

여기서 temp를 구할 때에는, binary search😅를 이용하여 배열안에서 `a[i]-b[i]` 바로 왼쪽의 index를 반환하도록 하면 된다.

해당 dp배열의 원소 중 `dp[i]+n-i`가 최소인 원소가 답이 된다. 즉, 해당 원소가 active되어 있고 오른쪽 비콘들은 모두 deactive되어 있는 경우의 deactive 비콘의 개수 중 최소가 답이된다.
